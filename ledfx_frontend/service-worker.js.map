{"version":3,"sources":["../node_modules/workbox-strategies/_version.js","../node_modules/workbox-expiration/_version.js","../node_modules/workbox-routing/_version.js","../node_modules/workbox-precaching/_version.js","../node_modules/workbox-core/_version.js","../webpack/bootstrap","../node_modules/workbox-core/_private/logger.js","../node_modules/workbox-core/models/messages/messageGenerator.js","../node_modules/workbox-core/_private/WorkboxError.js","../node_modules/workbox-core/_private/assert.js","../node_modules/workbox-core/models/quotaErrorCallbacks.js","../node_modules/workbox-core/_private/cacheNames.js","../node_modules/workbox-core/_private/cacheMatchIgnoreParams.js","../node_modules/workbox-core/_private/canConstructReadableStream.js","../node_modules/workbox-core/_private/canConstructResponseFromBodyStream.js","../node_modules/workbox-core/_private/dontWaitFor.js","../node_modules/workbox-core/_private/Deferred.js","../node_modules/workbox-core/_private/getFriendlyURL.js","../node_modules/workbox-core/_private/timeout.js","../node_modules/workbox-core/_private/waitUntil.js","../node_modules/workbox-core/copyResponse.js","../node_modules/idb/build/wrap-idb-value.js","../node_modules/idb/build/index.js","../node_modules/workbox-expiration/models/CacheTimestampsModel.js","../node_modules/workbox-expiration/CacheExpiration.js","../node_modules/workbox-precaching/utils/createCacheKey.js","../node_modules/workbox-precaching/utils/PrecacheInstallReportPlugin.js","../node_modules/workbox-precaching/utils/PrecacheCacheKeyPlugin.js","../node_modules/workbox-strategies/StrategyHandler.js","../node_modules/workbox-core/_private/executeQuotaErrorCallbacks.js","../node_modules/workbox-strategies/Strategy.js","../node_modules/workbox-precaching/PrecacheStrategy.js","../node_modules/workbox-precaching/PrecacheController.js","../node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js","../node_modules/workbox-routing/utils/constants.js","../node_modules/workbox-routing/utils/normalizeHandler.js","../node_modules/workbox-routing/Route.js","../node_modules/workbox-routing/RegExpRoute.js","../node_modules/workbox-routing/Router.js","../node_modules/workbox-routing/utils/getOrCreateDefaultRouter.js","../node_modules/workbox-routing/registerRoute.js","../node_modules/workbox-precaching/PrecacheRoute.js","../node_modules/workbox-precaching/utils/generateURLVariations.js","../node_modules/workbox-precaching/utils/removeIgnoredSearchParams.js","../node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.js","../node_modules/workbox-precaching/precacheAndRoute.js","../node_modules/workbox-core/clientsClaim.js","../node_modules/workbox-precaching/precache.js","service-worker.ts","../node_modules/workbox-precaching/addRoute.js","../node_modules/workbox-precaching/createHandlerBoundToURL.js","../node_modules/workbox-strategies/StaleWhileRevalidate.js","../node_modules/workbox-expiration/ExpirationPlugin.js","../node_modules/workbox-core/registerQuotaErrorCallback.js"],"names":["self","_","e","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","messageGenerator","code","msg","_len","arguments","length","args","Array","_key","JSON","stringify","Error","constructor","errorCode","details","super","this","name","quotaErrorCallbacks","Set","_cacheNameDetails","googleAnalytics","precache","prefix","runtime","suffix","registration","scope","_createCacheName","cacheName","filter","value","join","userCacheName","stripParams","fullURL","ignoreParams","strippedURL","URL","param","searchParams","delete","href","dontWaitFor","promise","then","Deferred","Promise","resolve","reject","getFriendlyURL","url","String","location","replace","RegExp","origin","ms","setTimeout","waitUntil","event","asyncFn","returnPromise","async","copyResponse","response","modifier","clonedResponse","clone","responseInit","headers","Headers","status","statusText","modifiedResponseInit","body","testResponse","Response","error","canConstructResponseFromBodyStream","blob","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","get","target","prop","receiver","IDBTransaction","objectStoreNames","objectStore","wrap","set","has","wrapFunction","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","_len2","_key2","apply","unwrap","_len3","_key3","storeNames","tx","call","sort","transformCachableValue","done","unlisten","removeEventListener","complete","DOMException","addEventListener","cacheDonePromiseForTransaction","object","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","request","success","result","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","useIndex","isWrite","method","storeName","store","index","shift","all","oldTraps","callback","CACHE_OBJECT_STORE","normalizeURL","unNormalizedUrl","hash","CacheTimestampsModel","_db","_cacheName","_upgradeDb","db","objStore","createObjectStore","keyPath","createIndex","unique","_upgradeDbAndDeleteOldDbs","blocked","indexedDB","deleteDatabase","oldVersion","deleteDB","setTimestamp","timestamp","entry","id","_getId","getDb","durability","put","getTimestamp","expireEntries","minTimestamp","maxCount","cursor","openCursor","entriesToDelete","entriesNotDeletedCount","push","urlsDeleted","version","upgrade","blocking","terminated","open","openPromise","newVersion","openDB","bind","CacheExpiration","config","_isRunning","_rerunRequested","_maxEntries","maxEntries","_maxAgeSeconds","maxAgeSeconds","_matchOptions","matchOptions","_timestampModel","Date","now","urlsExpired","cache","caches","updateTimestamp","isURLExpired","expireOlderThan","Infinity","createCacheKey","urlObject","cacheKey","revision","cacheKeyURL","originalURL","PrecacheInstallReportPlugin","updatedURLs","notUpdatedURLs","handlerWillStart","state","_ref","originalRequest","cachedResponseWillBeUsed","cachedResponse","_ref2","type","Request","PrecacheCacheKeyPlugin","precacheController","cacheKeyWillBeUsed","params","_precacheController","getCacheKeyForURL","toRequest","input","StrategyHandler","strategy","options","_cacheKeys","Object","assign","_strategy","_handlerDeferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","plugin","fetch","mode","FetchEvent","preloadResponse","possiblePreloadResponse","hasCallback","cb","iterateCallbacks","err","thrownErrorMessage","message","pluginFilteredRequest","fetchResponse","fetchOptions","runCallbacks","fetchAndCachePut","responseClone","cachePut","cacheMatch","key","effectiveRequest","getCacheKey","multiMatchOptions","match","responseToCache","_ensureResponseSafeToCache","hasCacheUpdateCallback","oldResponse","strippedRequestURL","keysOptions","ignoreSearch","cacheKeys","keys","cacheMatchIgnoreParams","executeQuotaErrorCallbacks","newResponse","statefulCallback","statefulParam","doneWaiting","destroy","pluginsUsed","handle","responseDone","handleAll","handler","_getResponse","_awaitComplete","_handle","waitUntilError","PrecacheStrategy","_fallbackToNetwork","fallbackToNetwork","copyRedirectedCacheableResponsesPlugin","_handleInstall","_handleFetch","integrityInManifest","integrity","integrityInRequest","noIntegrityConflict","_useDefaultCacheabilityPluginIfNeeded","defaultPluginIndex","cacheWillUpdatePluginCount","entries","defaultPrecacheCacheabilityPlugin","cacheWillUpdate","splice","redirected","PrecacheController","_urlsToCacheKeys","_urlsToCacheModes","_cacheKeysToIntegrities","install","activate","addToCacheList","_installAndActiveListenersAdded","urlsToWarnAbout","cacheMode","firstEntry","secondEntry","warningMessage","console","warn","installReportPlugin","credentials","currentlyCachedRequests","expectedCacheKeys","values","deletedURLs","getURLsToCacheKeys","getCachedURLs","getIntegrityForCacheKey","matchPrecache","createHandlerBoundToURL","normalizeHandler","Route","setCatchHandler","catchHandler","RegExpRoute","regExp","exec","slice","Router","_routes","_defaultHandlerMap","routes","addFetchListener","responsePromise","handleRequest","respondWith","addCacheListener","data","payload","requestPromises","urlsToCache","map","ports","postMessage","protocol","startsWith","sameOrigin","route","findMatchingRoute","_catchHandler","catchErr","matchResult","isArray","setDefaultHandler","registerRoute","unregisterRoute","routeIndex","indexOf","defaultRouter","capture","captureUrl","moduleName","funcName","paramName","PrecacheRoute","urlsToCacheKeys","possibleURL","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","urlWithoutIgnoredParams","test","removeIgnoredSearchParams","pathname","endsWith","directoryURL","cleanURL","additionalURLs","urlToAttempt","generateURLVariations","cacheOkAndOpaquePlugin","clients","claim","__WB_MANIFEST","addRoute","fileExtensionRegexp","p","unshift","fetchAndCachePromise","isFresh","_isResponseDateFresh","cacheExpiration","_getCacheExpiration","updateTimestampDone","cacheDidUpdate","_config","_cacheExpirations","purgeOnQuotaError","add","registerQuotaErrorCallback","deleteCacheAndMetadata","dateHeaderTimestamp","_getDateHeaderTimestamp","dateHeader","headerTime","getTime","isNaN","skipWaiting"],"mappings":"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","file":"service-worker.js","sourceRoot":"","sourcesContent":["\"use strict\";\n\n// @ts-ignore\ntry {\n  self['workbox:strategies:7.2.0'] && _();\n} catch (e) {}","\"use strict\";\n\n// @ts-ignore\ntry {\n  self['workbox:expiration:7.2.0'] && _();\n} catch (e) {}","\"use strict\";\n\n// @ts-ignore\ntry {\n  self['workbox:routing:7.2.0'] && _();\n} catch (e) {}","\"use strict\";\n\n// @ts-ignore\ntry {\n  self['workbox:precaching:7.2.0'] && _();\n} catch (e) {}","\"use strict\";\n\n// @ts-ignore\ntry {\n  self['workbox:core:7.2.0'] && _();\n} catch (e) {}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst logger = process.env.NODE_ENV === 'production' ? null : (() => {\n  // Don't overwrite this value if it's already set.\n  // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923\n  if (!('__WB_DISABLE_DEV_LOGS' in globalThis)) {\n    self.__WB_DISABLE_DEV_LOGS = false;\n  }\n  let inGroup = false;\n  const methodToColorMap = {\n    debug: `#7f8c8d`,\n    log: `#2ecc71`,\n    warn: `#f39c12`,\n    error: `#c0392b`,\n    groupCollapsed: `#3498db`,\n    groupEnd: null // No colored prefix on groupEnd\n  };\n  const print = function (method, args) {\n    if (self.__WB_DISABLE_DEV_LOGS) {\n      return;\n    }\n    if (method === 'groupCollapsed') {\n      // Safari doesn't print all console.groupCollapsed() arguments:\n      // https://bugs.webkit.org/show_bug.cgi?id=182754\n      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        console[method](...args);\n        return;\n      }\n    }\n    const styles = [`background: ${methodToColorMap[method]}`, `border-radius: 0.5em`, `color: white`, `font-weight: bold`, `padding: 2px 0.5em`];\n    // When in a group, the workbox prefix is not displayed.\n    const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n    console[method](...logPrefix, ...args);\n    if (method === 'groupCollapsed') {\n      inGroup = true;\n    }\n    if (method === 'groupEnd') {\n      inGroup = false;\n    }\n  };\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  const api = {};\n  const loggerMethods = Object.keys(methodToColorMap);\n  for (const key of loggerMethods) {\n    const method = key;\n    api[method] = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      print(method, args);\n    };\n  }\n  return api;\n})();\nexport { logger };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messages } from './messages.js';\nimport '../../_version.js';\nconst fallback = function (code) {\n  let msg = code;\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  if (args.length > 0) {\n    msg += ` :: ${JSON.stringify(args)}`;\n  }\n  return msg;\n};\nconst generatorFunction = function (code) {\n  let details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const message = messages[code];\n  if (!message) {\n    throw new Error(`Unable to find message for code '${code}'.`);\n  }\n  return message(details);\n};\nexport const messageGenerator = process.env.NODE_ENV === 'production' ? fallback : generatorFunction;","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messageGenerator } from '../models/messages/messageGenerator.js';\nimport '../_version.js';\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n  /**\n   *\n   * @param {string} errorCode The error code that\n   * identifies this particular error.\n   * @param {Object=} details Any relevant arguments\n   * that will help developers identify issues should\n   * be added as a key on the context object.\n   */\n  constructor(errorCode, details) {\n    const message = messageGenerator(errorCode, details);\n    super(message);\n    this.name = errorCode;\n    this.details = details;\n  }\n}\nexport { WorkboxError };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from '../_private/WorkboxError.js';\nimport '../_version.js';\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, details) => {\n  if (!Array.isArray(value)) {\n    throw new WorkboxError('not-an-array', details);\n  }\n};\nconst hasMethod = (object, expectedMethod, details) => {\n  const type = typeof object[expectedMethod];\n  if (type !== 'function') {\n    details['expectedMethod'] = expectedMethod;\n    throw new WorkboxError('missing-a-method', details);\n  }\n};\nconst isType = (object, expectedType, details) => {\n  if (typeof object !== expectedType) {\n    details['expectedType'] = expectedType;\n    throw new WorkboxError('incorrect-type', details);\n  }\n};\nconst isInstance = (object,\n// Need the general type to do the check later.\n// eslint-disable-next-line @typescript-eslint/ban-types\nexpectedClass, details) => {\n  if (!(object instanceof expectedClass)) {\n    details['expectedClassName'] = expectedClass.name;\n    throw new WorkboxError('incorrect-class', details);\n  }\n};\nconst isOneOf = (value, validValues, details) => {\n  if (!validValues.includes(value)) {\n    details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;\n    throw new WorkboxError('invalid-value', details);\n  }\n};\nconst isArrayOfClass = (value,\n// Need general type to do check later.\nexpectedClass,\n// eslint-disable-line\ndetails) => {\n  const error = new WorkboxError('not-array-of-class', details);\n  if (!Array.isArray(value)) {\n    throw error;\n  }\n  for (const item of value) {\n    if (!(item instanceof expectedClass)) {\n      throw error;\n    }\n  }\n};\nconst finalAssertExports = process.env.NODE_ENV === 'production' ? null : {\n  hasMethod,\n  isArray,\n  isInstance,\n  isOneOf,\n  isType,\n  isArrayOfClass\n};\nexport { finalAssertExports as assert };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n// Callbacks to be executed whenever there's a quota error.\n// Can't change Function type right now.\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst quotaErrorCallbacks = new Set();\nexport { quotaErrorCallbacks };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst _cacheNameDetails = {\n  googleAnalytics: 'googleAnalytics',\n  precache: 'precache-v2',\n  prefix: 'workbox',\n  runtime: 'runtime',\n  suffix: typeof registration !== 'undefined' ? registration.scope : ''\n};\nconst _createCacheName = cacheName => {\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-');\n};\nconst eachCacheNameDetail = fn => {\n  for (const key of Object.keys(_cacheNameDetails)) {\n    fn(key);\n  }\n};\nexport const cacheNames = {\n  updateDetails: details => {\n    eachCacheNameDetail(key => {\n      if (typeof details[key] === 'string') {\n        _cacheNameDetails[key] = details[key];\n      }\n    });\n  },\n  getGoogleAnalyticsName: userCacheName => {\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n  },\n  getPrecacheName: userCacheName => {\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\n  },\n  getPrefix: () => {\n    return _cacheNameDetails.prefix;\n  },\n  getRuntimeName: userCacheName => {\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n  },\n  getSuffix: () => {\n    return _cacheNameDetails.suffix;\n  }\n};","/*\n  Copyright 2020 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nfunction stripParams(fullURL, ignoreParams) {\n  const strippedURL = new URL(fullURL);\n  for (const param of ignoreParams) {\n    strippedURL.searchParams.delete(param);\n  }\n  return strippedURL.href;\n}\n/**\n * Matches an item in the cache, ignoring specific URL params. This is similar\n * to the `ignoreSearch` option, but it allows you to ignore just specific\n * params (while continuing to match on the others).\n *\n * @private\n * @param {Cache} cache\n * @param {Request} request\n * @param {Object} matchOptions\n * @param {Array<string>} ignoreParams\n * @return {Promise<Response|undefined>}\n */\nasync function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n  const strippedRequestURL = stripParams(request.url, ignoreParams);\n  // If the request doesn't include any ignored params, match as normal.\n  if (request.url === strippedRequestURL) {\n    return cache.match(request, matchOptions);\n  }\n  // Otherwise, match by comparing keys\n  const keysOptions = Object.assign(Object.assign({}, matchOptions), {\n    ignoreSearch: true\n  });\n  const cacheKeys = await cache.keys(request, keysOptions);\n  for (const cacheKey of cacheKeys) {\n    const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n    if (strippedRequestURL === strippedCacheKeyURL) {\n      return cache.match(cacheKey, matchOptions);\n    }\n  }\n  return;\n}\nexport { cacheMatchIgnoreParams };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nlet supportStatus;\n/**\n * A utility function that determines whether the current browser supports\n * constructing a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * object.\n *\n * @return {boolean} `true`, if the current browser can successfully\n *     construct a `ReadableStream`, `false` otherwise.\n *\n * @private\n */\nfunction canConstructReadableStream() {\n  if (supportStatus === undefined) {\n    // See https://github.com/GoogleChrome/workbox/issues/1473\n    try {\n      new ReadableStream({\n        start() {}\n      });\n      supportStatus = true;\n    } catch (error) {\n      supportStatus = false;\n    }\n  }\n  return supportStatus;\n}\nexport { canConstructReadableStream };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nlet supportStatus;\n/**\n * A utility function that determines whether the current browser supports\n * constructing a new `Response` from a `response.body` stream.\n *\n * @return {boolean} `true`, if the current browser can successfully\n *     construct a `Response` from a `response.body` stream, `false` otherwise.\n *\n * @private\n */\nfunction canConstructResponseFromBodyStream() {\n  if (supportStatus === undefined) {\n    const testResponse = new Response('');\n    if ('body' in testResponse) {\n      try {\n        new Response(testResponse.body);\n        supportStatus = true;\n      } catch (error) {\n        supportStatus = false;\n      }\n    }\n    supportStatus = false;\n  }\n  return supportStatus;\n}\nexport { canConstructResponseFromBodyStream };","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\nexport function dontWaitFor(promise) {\n  // Effective no-op.\n  void promise.then(() => {});\n}","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nclass Deferred {\n  /**\n   * Creates a promise and exposes its resolve and reject functions as methods.\n   */\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\nexport { Deferred };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst getFriendlyURL = url => {\n  const urlObj = new URL(String(url), location.href);\n  // See https://github.com/GoogleChrome/workbox/issues/2323\n  // We want to include everything, except for the origin if it's same-origin.\n  return urlObj.href.replace(new RegExp(`^${location.origin}`), '');\n};\nexport { getFriendlyURL };","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Returns a promise that resolves and the passed number of milliseconds.\n * This utility is an async/await-friendly version of `setTimeout`.\n *\n * @param {number} ms\n * @return {Promise}\n * @private\n */\nexport function timeout(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}","/*\n  Copyright 2020 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A utility method that makes it easier to use `event.waitUntil` with\n * async functions and return the result.\n *\n * @param {ExtendableEvent} event\n * @param {Function} asyncFn\n * @return {Function}\n * @private\n */\nfunction waitUntil(event, asyncFn) {\n  const returnPromise = asyncFn();\n  event.waitUntil(returnPromise);\n  return returnPromise;\n}\nexport { waitUntil };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { canConstructResponseFromBodyStream } from './_private/canConstructResponseFromBodyStream.js';\nimport { WorkboxError } from './_private/WorkboxError.js';\nimport './_version.js';\n/**\n * Allows developers to copy a response and modify its `headers`, `status`,\n * or `statusText` values (the values settable via a\n * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\n * object in the constructor).\n * To modify these values, pass a function as the second argument. That\n * function will be invoked with a single object with the response properties\n * `{headers, status, statusText}`. The return value of this function will\n * be used as the `ResponseInit` for the new `Response`. To change the values\n * either modify the passed parameter(s) and return it, or return a totally\n * new object.\n *\n * This method is intentionally limited to same-origin responses, regardless of\n * whether CORS was used or not.\n *\n * @param {Response} response\n * @param {Function} modifier\n * @memberof workbox-core\n */\nasync function copyResponse(response, modifier) {\n  let origin = null;\n  // If response.url isn't set, assume it's cross-origin and keep origin null.\n  if (response.url) {\n    const responseURL = new URL(response.url);\n    origin = responseURL.origin;\n  }\n  if (origin !== self.location.origin) {\n    throw new WorkboxError('cross-origin-copy-response', {\n      origin\n    });\n  }\n  const clonedResponse = response.clone();\n  // Create a fresh `ResponseInit` object by cloning the headers.\n  const responseInit = {\n    headers: new Headers(clonedResponse.headers),\n    status: clonedResponse.status,\n    statusText: clonedResponse.statusText\n  };\n  // Apply any user modifications.\n  const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n  // Create the new response from the body stream and `ResponseInit`\n  // modifications. Note: not all browsers support the Response.body stream,\n  // so fall back to reading the entire body into memory as a blob.\n  const body = canConstructResponseFromBodyStream() ? clonedResponse.body : await clonedResponse.blob();\n  return new Response(body, modifiedResponseInit);\n}\nexport { copyResponse };","const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  promise.then(value => {\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n    // (see wrapFunction).\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    }\n    // Catching to avoid \"Uncaught Promise exceptions\"\n  }).catch(() => {});\n  // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n    const error = () => {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  });\n  // Cache it for later retrieval.\n  transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target);\n      // Polyfill for objectStoreNames because of Edge.\n      if (prop === 'objectStoreNames') {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      }\n      // Make tx.store return the only store in the transaction, or undefined if there are many.\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    }\n    // Else transform whatever we get back.\n    return wrap(target[prop]);\n  },\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n    return prop in target;\n  }\n};\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n    return function (storeNames) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      const tx = func.call(unwrap(this), storeNames, ...args);\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  }\n  // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value);\n  // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n  // Return the same value back if we're not going to transform it.\n  return value;\n}\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value);\n  // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n  if (transformCache.has(value)) return transformCache.get(value);\n  const newValue = transformCachableValue(value);\n  // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n  return newValue;\n}\nconst unwrap = value => reverseTransformCache.get(value);\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version) {\n  let {\n    blocked,\n    upgrade,\n    blocking,\n    terminated\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const request = indexedDB.open(name, version);\n  const openPromise = wrap(request);\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', event => {\n      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n    });\n  }\n  if (blocked) {\n    request.addEventListener('blocked', event => blocked(\n    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n    event.oldVersion, event.newVersion, event));\n  }\n  openPromise.then(db => {\n    if (terminated) db.addEventListener('close', () => terminated());\n    if (blocking) {\n      db.addEventListener('versionchange', event => blocking(event.oldVersion, event.newVersion, event));\n    }\n  }).catch(() => {});\n  return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name) {\n  let {\n    blocked\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const request = indexedDB.deleteDatabase(name);\n  if (blocked) {\n    request.addEventListener('blocked', event => blocked(\n    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n    event.oldVersion, event));\n  }\n  return wrap(request).then(() => undefined);\n}\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n    return;\n  }\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, '');\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n  if (\n  // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n    return;\n  }\n  const method = async function (storeName) {\n    // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n    let target = tx.store;\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (useIndex) target = target.index(args.shift());\n    // Must reject if op rejects.\n    // If it's a write operation, must reject if tx.done rejects.\n    // Must reject with op rejection first.\n    // Must resolve with op value.\n    // Must handle both promises (no unhandled rejections)\n    return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\n  };\n  cachedMethods.set(prop, method);\n  return method;\n}\nreplaceTraps(oldTraps => ({\n  ...oldTraps,\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\nexport { deleteDB, openDB };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { openDB, deleteDB } from 'idb';\nimport '../_version.js';\nconst DB_NAME = 'workbox-expiration';\nconst CACHE_OBJECT_STORE = 'cache-entries';\nconst normalizeURL = unNormalizedUrl => {\n  const url = new URL(unNormalizedUrl, location.href);\n  url.hash = '';\n  return url.href;\n};\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._db = null;\n    this._cacheName = cacheName;\n  }\n  /**\n   * Performs an upgrade of indexedDB.\n   *\n   * @param {IDBPDatabase<CacheDbSchema>} db\n   *\n   * @private\n   */\n  _upgradeDb(db) {\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n    // have to use the `id` keyPath here and create our own values (a\n    // concatenation of `url + cacheName`) instead of simply using\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n    const objStore = db.createObjectStore(CACHE_OBJECT_STORE, {\n      keyPath: 'id'\n    });\n    // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\n    // instead of doing both these indexes.\n    objStore.createIndex('cacheName', 'cacheName', {\n      unique: false\n    });\n    objStore.createIndex('timestamp', 'timestamp', {\n      unique: false\n    });\n  }\n  /**\n   * Performs an upgrade of indexedDB and deletes deprecated DBs.\n   *\n   * @param {IDBPDatabase<CacheDbSchema>} db\n   *\n   * @private\n   */\n  _upgradeDbAndDeleteOldDbs(db) {\n    this._upgradeDb(db);\n    if (this._cacheName) {\n      void deleteDB(this._cacheName);\n    }\n  }\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n  async setTimestamp(url, timestamp) {\n    url = normalizeURL(url);\n    const entry = {\n      url,\n      timestamp,\n      cacheName: this._cacheName,\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      id: this._getId(url)\n    };\n    const db = await this.getDb();\n    const tx = db.transaction(CACHE_OBJECT_STORE, 'readwrite', {\n      durability: 'relaxed'\n    });\n    await tx.store.put(entry);\n    await tx.done;\n  }\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number | undefined}\n   *\n   * @private\n   */\n  async getTimestamp(url) {\n    const db = await this.getDb();\n    const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n    return entry === null || entry === void 0 ? void 0 : entry.timestamp;\n  }\n  /**\n   * Iterates through all the entries in the object store (from newest to\n   * oldest) and removes entries once either `maxCount` is reached or the\n   * entry's timestamp is less than `minTimestamp`.\n   *\n   * @param {number} minTimestamp\n   * @param {number} maxCount\n   * @return {Array<string>}\n   *\n   * @private\n   */\n  async expireEntries(minTimestamp, maxCount) {\n    const db = await this.getDb();\n    let cursor = await db.transaction(CACHE_OBJECT_STORE).store.index('timestamp').openCursor(null, 'prev');\n    const entriesToDelete = [];\n    let entriesNotDeletedCount = 0;\n    while (cursor) {\n      const result = cursor.value;\n      // TODO(philipwalton): once we can use a multi-key index, we\n      // won't have to check `cacheName` here.\n      if (result.cacheName === this._cacheName) {\n        // Delete an entry if it's older than the max age or\n        // if we already have the max number allowed.\n        if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n          // TODO(philipwalton): we should be able to delete the\n          // entry right here, but doing so causes an iteration\n          // bug in Safari stable (fixed in TP). Instead we can\n          // store the keys of the entries to delete, and then\n          // delete the separate transactions.\n          // https://github.com/GoogleChrome/workbox/issues/1978\n          // cursor.delete();\n          // We only need to return the URL, not the whole entry.\n          entriesToDelete.push(cursor.value);\n        } else {\n          entriesNotDeletedCount++;\n        }\n      }\n      cursor = await cursor.continue();\n    }\n    // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n    // we should be able to remove this loop and do the entry deletion in the\n    // cursor loop above:\n    // https://github.com/GoogleChrome/workbox/issues/1978\n    const urlsDeleted = [];\n    for (const entry of entriesToDelete) {\n      await db.delete(CACHE_OBJECT_STORE, entry.id);\n      urlsDeleted.push(entry.url);\n    }\n    return urlsDeleted;\n  }\n  /**\n   * Takes a URL and returns an ID that will be unique in the object store.\n   *\n   * @param {string} url\n   * @return {string}\n   *\n   * @private\n   */\n  _getId(url) {\n    // Creating an ID from the URL and cache name won't be necessary once\n    // Edge switches to Chromium and all browsers we support work with\n    // array keyPaths.\n    return this._cacheName + '|' + normalizeURL(url);\n  }\n  /**\n   * Returns an open connection to the database.\n   *\n   * @private\n   */\n  async getDb() {\n    if (!this._db) {\n      this._db = await openDB(DB_NAME, 1, {\n        upgrade: this._upgradeDbAndDeleteOldDbs.bind(this)\n      });\n    }\n    return this._db;\n  }\n}\nexport { CacheTimestampsModel };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox-expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n   * that will be used when calling `delete()` on the cache.\n   */\n  constructor(cacheName) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._isRunning = false;\n    this._rerunRequested = false;\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName'\n      });\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor'\n        });\n      }\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        });\n      }\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        });\n      }\n    }\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._matchOptions = config.matchOptions;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n    const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n    const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n    // Delete URLs from the cache\n    const cache = await self.caches.open(this._cacheName);\n    for (const url of urlsExpired) {\n      await cache.delete(url, this._matchOptions);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n        urlsExpired.forEach(url => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      dontWaitFor(this.expireEntries());\n    }\n  }\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url'\n      });\n    }\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (!this._maxAgeSeconds) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds'\n        });\n      }\n      return false;\n    } else {\n      const timestamp = await this._timestampModel.getTimestamp(url);\n      const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n      return timestamp !== undefined ? timestamp < expireOlderThan : true;\n    }\n  }\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n}\nexport { CacheExpiration };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport '../_version.js';\n// Name of the search parameter used to store revision info.\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object|string} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function createCacheKey(entry) {\n  if (!entry) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {\n      entry\n    });\n  }\n  // If a precache manifest entry is a string, it's assumed to be a versioned\n  // URL, like '/app.abcd1234.js'. Return as-is.\n  if (typeof entry === 'string') {\n    const urlObject = new URL(entry, location.href);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href\n    };\n  }\n  const {\n    revision,\n    url\n  } = entry;\n  if (!url) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {\n      entry\n    });\n  }\n  // If there's just a URL and no revision, then it's also assumed to be a\n  // versioned URL.\n  if (!revision) {\n    const urlObject = new URL(url, location.href);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href\n    };\n  }\n  // Otherwise, construct a properly versioned URL using the custom Workbox\n  // search parameter along with the revision info.\n  const cacheKeyURL = new URL(url, location.href);\n  const originalURL = new URL(url, location.href);\n  cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n  return {\n    cacheKey: cacheKeyURL.href,\n    url: originalURL.href\n  };\n}","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A plugin, designed to be used with PrecacheController, to determine the\n * of assets that were updated (or not updated) during the install event.\n *\n * @private\n */\nclass PrecacheInstallReportPlugin {\n  constructor() {\n    this.updatedURLs = [];\n    this.notUpdatedURLs = [];\n    this.handlerWillStart = async _ref => {\n      let {\n        request,\n        state\n      } = _ref;\n      // TODO: `state` should never be undefined...\n      if (state) {\n        state.originalRequest = request;\n      }\n    };\n    this.cachedResponseWillBeUsed = async _ref2 => {\n      let {\n        event,\n        state,\n        cachedResponse\n      } = _ref2;\n      if (event.type === 'install') {\n        if (state && state.originalRequest && state.originalRequest instanceof Request) {\n          // TODO: `state` should never be undefined...\n          const url = state.originalRequest.url;\n          if (cachedResponse) {\n            this.notUpdatedURLs.push(url);\n          } else {\n            this.updatedURLs.push(url);\n          }\n        }\n      }\n      return cachedResponse;\n    };\n  }\n}\nexport { PrecacheInstallReportPlugin };","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A plugin, designed to be used with PrecacheController, to translate URLs into\n * the corresponding cache key, based on the current revision info.\n *\n * @private\n */\nclass PrecacheCacheKeyPlugin {\n  constructor(_ref) {\n    let {\n      precacheController\n    } = _ref;\n    this.cacheKeyWillBeUsed = async _ref2 => {\n      let {\n        request,\n        params\n      } = _ref2;\n      // Params is type any, can't change right now.\n      /* eslint-disable */\n      const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) || this._precacheController.getCacheKeyForURL(request.url);\n      /* eslint-enable */\n      return cacheKey ? new Request(cacheKey, {\n        headers: request.headers\n      }) : request;\n    };\n    this._precacheController = precacheController;\n  }\n}\nexport { PrecacheCacheKeyPlugin };","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n  return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * {@link workbox-strategies.Strategy~handle} or\n * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof workbox-strategies\n */\nclass StrategyHandler {\n  /**\n   * Creates a new instance associated with the passed strategy and event\n   * that's handling the request.\n   *\n   * The constructor also initializes the state that will be passed to each of\n   * the plugins handling this request.\n   *\n   * @param {workbox-strategies.Strategy} strategy\n   * @param {Object} options\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params] The return value from the\n   *     {@link workbox-routing~matchCallback} (if applicable).\n   */\n  constructor(strategy, options) {\n    this._cacheKeys = {};\n    /**\n     * The request the strategy is performing (passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * @name request\n     * @instance\n     * @type {Request}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * The event associated with this request.\n     * @name event\n     * @instance\n     * @type {ExtendableEvent}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * A `URL` instance of `request.url` (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `url` param will be present if the strategy was invoked\n     * from a workbox `Route` object.\n     * @name url\n     * @instance\n     * @type {URL|undefined}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * A `param` value (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `param` param will be present if the strategy was invoked\n     * from a workbox `Route` object and the\n     * {@link workbox-routing~matchCallback} returned\n     * a truthy value (it will be that value).\n     * @name params\n     * @instance\n     * @type {*|undefined}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(options.event, ExtendableEvent, {\n        moduleName: 'workbox-strategies',\n        className: 'StrategyHandler',\n        funcName: 'constructor',\n        paramName: 'options.event'\n      });\n    }\n    Object.assign(this, options);\n    this.event = options.event;\n    this._strategy = strategy;\n    this._handlerDeferred = new Deferred();\n    this._extendLifetimePromises = [];\n    // Copy the plugins list (since it's mutable on the strategy),\n    // so any mutations don't affect this handler instance.\n    this._plugins = [...strategy.plugins];\n    this._pluginStateMap = new Map();\n    for (const plugin of this._plugins) {\n      this._pluginStateMap.set(plugin, {});\n    }\n    this.event.waitUntil(this._handlerDeferred.promise);\n  }\n  /**\n   * Fetches a given request (and invokes any applicable plugin callback\n   * methods) using the `fetchOptions` (for non-navigation requests) and\n   * `plugins` defined on the `Strategy` object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - `requestWillFetch()`\n   * - `fetchDidSucceed()`\n   * - `fetchDidFail()`\n   *\n   * @param {Request|string} input The URL or request to fetch.\n   * @return {Promise<Response>}\n   */\n  async fetch(input) {\n    const {\n      event\n    } = this;\n    let request = toRequest(input);\n    if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {\n      const possiblePreloadResponse = await event.preloadResponse;\n      if (possiblePreloadResponse) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);\n        }\n        return possiblePreloadResponse;\n      }\n    }\n    // If there is a fetchDidFail plugin, we need to save a clone of the\n    // original request before it's either modified by a requestWillFetch\n    // plugin or before the original request's body is consumed via fetch().\n    const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;\n    try {\n      for (const cb of this.iterateCallbacks('requestWillFetch')) {\n        request = await cb({\n          request: request.clone(),\n          event\n        });\n      }\n    } catch (err) {\n      if (err instanceof Error) {\n        throw new WorkboxError('plugin-error-request-will-fetch', {\n          thrownErrorMessage: err.message\n        });\n      }\n    }\n    // The request can be altered by plugins with `requestWillFetch` making\n    // the original request (most likely from a `fetch` event) different\n    // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n    const pluginFilteredRequest = request.clone();\n    try {\n      let fetchResponse;\n      // See https://github.com/GoogleChrome/workbox/issues/1796\n      fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);\n      }\n      for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n        fetchResponse = await callback({\n          event,\n          request: pluginFilteredRequest,\n          response: fetchResponse\n        });\n      }\n      return fetchResponse;\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);\n      }\n      // `originalRequest` will only exist if a `fetchDidFail` callback\n      // is being used (see above).\n      if (originalRequest) {\n        await this.runCallbacks('fetchDidFail', {\n          error: error,\n          event,\n          originalRequest: originalRequest.clone(),\n          request: pluginFilteredRequest.clone()\n        });\n      }\n      throw error;\n    }\n  }\n  /**\n   * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n   * the response generated by `this.fetch()`.\n   *\n   * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n   * so you do not have to manually call `waitUntil()` on the event.\n   *\n   * @param {Request|string} input The request or URL to fetch and cache.\n   * @return {Promise<Response>}\n   */\n  async fetchAndCachePut(input) {\n    const response = await this.fetch(input);\n    const responseClone = response.clone();\n    void this.waitUntil(this.cachePut(input, responseClone));\n    return response;\n  }\n  /**\n   * Matches a request from the cache (and invokes any applicable plugin\n   * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n   * defined on the strategy object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - cacheKeyWillBeUsed()\n   * - cachedResponseWillBeUsed()\n   *\n   * @param {Request|string} key The Request or URL to use as the cache key.\n   * @return {Promise<Response|undefined>} A matching response, if found.\n   */\n  async cacheMatch(key) {\n    const request = toRequest(key);\n    let cachedResponse;\n    const {\n      cacheName,\n      matchOptions\n    } = this._strategy;\n    const effectiveRequest = await this.getCacheKey(request, 'read');\n    const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {\n      cacheName\n    });\n    cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n      if (cachedResponse) {\n        logger.debug(`Found a cached response in '${cacheName}'.`);\n      } else {\n        logger.debug(`No cached response found in '${cacheName}'.`);\n      }\n    }\n    for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n      cachedResponse = (await callback({\n        cacheName,\n        matchOptions,\n        cachedResponse,\n        request: effectiveRequest,\n        event: this.event\n      })) || undefined;\n    }\n    return cachedResponse;\n  }\n  /**\n   * Puts a request/response pair in the cache (and invokes any applicable\n   * plugin callback methods) using the `cacheName` and `plugins` defined on\n   * the strategy object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - cacheKeyWillBeUsed()\n   * - cacheWillUpdate()\n   * - cacheDidUpdate()\n   *\n   * @param {Request|string} key The request or URL to use as the cache key.\n   * @param {Response} response The response to cache.\n   * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n   * not be cached, and `true` otherwise.\n   */\n  async cachePut(key, response) {\n    const request = toRequest(key);\n    // Run in the next task to avoid blocking other cache reads.\n    // https://github.com/w3c/ServiceWorker/issues/1397\n    await timeout(0);\n    const effectiveRequest = await this.getCacheKey(request, 'write');\n    if (process.env.NODE_ENV !== 'production') {\n      if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n        throw new WorkboxError('attempt-to-cache-non-get-request', {\n          url: getFriendlyURL(effectiveRequest.url),\n          method: effectiveRequest.method\n        });\n      }\n      // See https://github.com/GoogleChrome/workbox/issues/2818\n      const vary = response.headers.get('Vary');\n      if (vary) {\n        logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` + `has a 'Vary: ${vary}' header. ` + `Consider setting the {ignoreVary: true} option on your strategy ` + `to ensure cache matching and deletion works as expected.`);\n      }\n    }\n    if (!response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);\n      }\n      throw new WorkboxError('cache-put-with-no-response', {\n        url: getFriendlyURL(effectiveRequest.url)\n      });\n    }\n    const responseToCache = await this._ensureResponseSafeToCache(response);\n    if (!responseToCache) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` + `will not be cached.`, responseToCache);\n      }\n      return false;\n    }\n    const {\n      cacheName,\n      matchOptions\n    } = this._strategy;\n    const cache = await self.caches.open(cacheName);\n    const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n    const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(\n    // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n    // feature. Consider into ways to only add this behavior if using\n    // precaching.\n    cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Updating the '${cacheName}' cache with a new Response ` + `for ${getFriendlyURL(effectiveRequest.url)}.`);\n    }\n    try {\n      await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n    } catch (error) {\n      if (error instanceof Error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n          await executeQuotaErrorCallbacks();\n        }\n        throw error;\n      }\n    }\n    for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n      await callback({\n        cacheName,\n        oldResponse,\n        newResponse: responseToCache.clone(),\n        request: effectiveRequest,\n        event: this.event\n      });\n    }\n    return true;\n  }\n  /**\n   * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n   * executes any of those callbacks found in sequence. The final `Request`\n   * object returned by the last plugin is treated as the cache key for cache\n   * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n   * been registered, the passed request is returned unmodified\n   *\n   * @param {Request} request\n   * @param {string} mode\n   * @return {Promise<Request>}\n   */\n  async getCacheKey(request, mode) {\n    const key = `${request.url} | ${mode}`;\n    if (!this._cacheKeys[key]) {\n      let effectiveRequest = request;\n      for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n        effectiveRequest = toRequest(await callback({\n          mode,\n          request: effectiveRequest,\n          event: this.event,\n          // params has a type any can't change right now.\n          params: this.params // eslint-disable-line\n        }));\n      }\n      this._cacheKeys[key] = effectiveRequest;\n    }\n    return this._cacheKeys[key];\n  }\n  /**\n   * Returns true if the strategy has at least one plugin with the given\n   * callback.\n   *\n   * @param {string} name The name of the callback to check for.\n   * @return {boolean}\n   */\n  hasCallback(name) {\n    for (const plugin of this._strategy.plugins) {\n      if (name in plugin) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Runs all plugin callbacks matching the given name, in order, passing the\n   * given param object (merged ith the current plugin state) as the only\n   * argument.\n   *\n   * Note: since this method runs all plugins, it's not suitable for cases\n   * where the return value of a callback needs to be applied prior to calling\n   * the next callback. See\n   * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n   * below for how to handle that case.\n   *\n   * @param {string} name The name of the callback to run within each plugin.\n   * @param {Object} param The object to pass as the first (and only) param\n   *     when executing each callback. This object will be merged with the\n   *     current plugin state prior to callback execution.\n   */\n  async runCallbacks(name, param) {\n    for (const callback of this.iterateCallbacks(name)) {\n      // TODO(philipwalton): not sure why `any` is needed. It seems like\n      // this should work with `as WorkboxPluginCallbackParam[C]`.\n      await callback(param);\n    }\n  }\n  /**\n   * Accepts a callback and returns an iterable of matching plugin callbacks,\n   * where each callback is wrapped with the current handler state (i.e. when\n   * you call each callback, whatever object parameter you pass it will\n   * be merged with the plugin's current state).\n   *\n   * @param {string} name The name fo the callback to run\n   * @return {Array<Function>}\n   */\n  *iterateCallbacks(name) {\n    for (const plugin of this._strategy.plugins) {\n      if (typeof plugin[name] === 'function') {\n        const state = this._pluginStateMap.get(plugin);\n        const statefulCallback = param => {\n          const statefulParam = Object.assign(Object.assign({}, param), {\n            state\n          });\n          // TODO(philipwalton): not sure why `any` is needed. It seems like\n          // this should work with `as WorkboxPluginCallbackParam[C]`.\n          return plugin[name](statefulParam);\n        };\n        yield statefulCallback;\n      }\n    }\n  }\n  /**\n   * Adds a promise to the\n   * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n   * of the event event associated with the request being handled (usually a\n   * `FetchEvent`).\n   *\n   * Note: you can await\n   * {@link workbox-strategies.StrategyHandler~doneWaiting}\n   * to know when all added promises have settled.\n   *\n   * @param {Promise} promise A promise to add to the extend lifetime promises\n   *     of the event that triggered the request.\n   */\n  waitUntil(promise) {\n    this._extendLifetimePromises.push(promise);\n    return promise;\n  }\n  /**\n   * Returns a promise that resolves once all promises passed to\n   * {@link workbox-strategies.StrategyHandler~waitUntil}\n   * have settled.\n   *\n   * Note: any work done after `doneWaiting()` settles should be manually\n   * passed to an event's `waitUntil()` method (not this handler's\n   * `waitUntil()` method), otherwise the service worker thread my be killed\n   * prior to your work completing.\n   */\n  async doneWaiting() {\n    let promise;\n    while (promise = this._extendLifetimePromises.shift()) {\n      await promise;\n    }\n  }\n  /**\n   * Stops running the strategy and immediately resolves any pending\n   * `waitUntil()` promises.\n   */\n  destroy() {\n    this._handlerDeferred.resolve(null);\n  }\n  /**\n   * This method will call cacheWillUpdate on the available plugins (or use\n   * status === 200) to determine if the Response is safe and valid to cache.\n   *\n   * @param {Request} options.request\n   * @param {Response} options.response\n   * @return {Promise<Response|undefined>}\n   *\n   * @private\n   */\n  async _ensureResponseSafeToCache(response) {\n    let responseToCache = response;\n    let pluginsUsed = false;\n    for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n      responseToCache = (await callback({\n        request: this.request,\n        response: responseToCache,\n        event: this.event\n      })) || undefined;\n      pluginsUsed = true;\n      if (!responseToCache) {\n        break;\n      }\n    }\n    if (!pluginsUsed) {\n      if (responseToCache && responseToCache.status !== 200) {\n        responseToCache = undefined;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          if (responseToCache.status !== 200) {\n            if (responseToCache.status === 0) {\n              logger.warn(`The response for '${this.request.url}' ` + `is an opaque response. The caching strategy that you're ` + `using will not cache opaque responses by default.`);\n            } else {\n              logger.debug(`The response for '${this.request.url}' ` + `returned a status code of '${response.status}' and won't ` + `be cached as a result.`);\n            }\n          }\n        }\n      }\n    }\n    return responseToCache;\n  }\n}\nexport { StrategyHandler };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from '../_private/logger.js';\nimport { quotaErrorCallbacks } from '../models/quotaErrorCallbacks.js';\nimport '../_version.js';\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof workbox-core\n * @private\n */\nasync function executeQuotaErrorCallbacks() {\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log(`About to run ${quotaErrorCallbacks.size} ` + `callbacks to clean up caches.`);\n  }\n  for (const callback of quotaErrorCallbacks) {\n    await callback();\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(callback, 'is complete.');\n    }\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Finished running callbacks.');\n  }\n}\nexport { executeQuotaErrorCallbacks };","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\nclass Strategy {\n  /**\n   * Creates a new instance of the strategy and sets all documented option\n   * properties as public instance properties.\n   *\n   * Note: if a custom strategy class extends the base Strategy class and does\n   * not need more than these properties, it does not need to define its own\n   * constructor.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * {@link workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /**\n     * Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     *\n     * @type {string}\n     */\n    this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n    /**\n     * The list\n     * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * used by this strategy.\n     *\n     * @type {Array<Object>}\n     */\n    this.plugins = options.plugins || [];\n    /**\n     * Values passed along to the\n     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n     * of all fetch() requests made by this strategy.\n     *\n     * @type {Object}\n     */\n    this.fetchOptions = options.fetchOptions;\n    /**\n     * The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     *\n     * @type {Object}\n     */\n    this.matchOptions = options.matchOptions;\n  }\n  /**\n   * Perform a request strategy and returns a `Promise` that will resolve with\n   * a `Response`, invoking all relevant plugin callbacks.\n   *\n   * When a strategy instance is registered with a Workbox\n   * {@link workbox-routing.Route}, this method is automatically\n   * called when the route matches.\n   *\n   * Alternatively, this method can be used in a standalone `FetchEvent`\n   * listener by passing it to `event.respondWith()`.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   */\n  handle(options) {\n    const [responseDone] = this.handleAll(options);\n    return responseDone;\n  }\n  /**\n   * Similar to {@link workbox-strategies.Strategy~handle}, but\n   * instead of just returning a `Promise` that resolves to a `Response` it\n   * it will return an tuple of `[response, done]` promises, where the former\n   * (`response`) is equivalent to what `handle()` returns, and the latter is a\n   * Promise that will resolve once any promises that were added to\n   * `event.waitUntil()` as part of performing the strategy have completed.\n   *\n   * You can await the `done` promise to ensure any extra work performed by\n   * the strategy (usually caching responses) completes successfully.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   * @return {Array<Promise>} A tuple of [response, done]\n   *     promises that can be used to determine when the response resolves as\n   *     well as when the handler has completed all its work.\n   */\n  handleAll(options) {\n    // Allow for flexible options to be passed.\n    if (options instanceof FetchEvent) {\n      options = {\n        event: options,\n        request: options.request\n      };\n    }\n    const event = options.event;\n    const request = typeof options.request === 'string' ? new Request(options.request) : options.request;\n    const params = 'params' in options ? options.params : undefined;\n    const handler = new StrategyHandler(this, {\n      event,\n      request,\n      params\n    });\n    const responseDone = this._getResponse(handler, request, event);\n    const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n    // Return an array of promises, suitable for use with Promise.all().\n    return [responseDone, handlerDone];\n  }\n  async _getResponse(handler, request, event) {\n    await handler.runCallbacks('handlerWillStart', {\n      event,\n      request\n    });\n    let response = undefined;\n    try {\n      response = await this._handle(request, handler);\n      // The \"official\" Strategy subclasses all throw this error automatically,\n      // but in case a third-party Strategy doesn't, ensure that we have a\n      // consistent failure when there's no response or an error response.\n      if (!response || response.type === 'error') {\n        throw new WorkboxError('no-response', {\n          url: request.url\n        });\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        for (const callback of handler.iterateCallbacks('handlerDidError')) {\n          response = await callback({\n            error,\n            event,\n            request\n          });\n          if (response) {\n            break;\n          }\n        }\n      }\n      if (!response) {\n        throw error;\n      } else if (process.env.NODE_ENV !== 'production') {\n        logger.log(`While responding to '${getFriendlyURL(request.url)}', ` + `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` + `a handlerDidError plugin.`);\n      }\n    }\n    for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n      response = await callback({\n        event,\n        request,\n        response\n      });\n    }\n    return response;\n  }\n  async _awaitComplete(responseDone, handler, request, event) {\n    let response;\n    let error;\n    try {\n      response = await responseDone;\n    } catch (error) {\n      // Ignore errors, as response errors should be caught via the `response`\n      // promise above. The `done` promise will only throw for errors in\n      // promises passed to `handler.waitUntil()`.\n    }\n    try {\n      await handler.runCallbacks('handlerDidRespond', {\n        event,\n        request,\n        response\n      });\n      await handler.doneWaiting();\n    } catch (waitUntilError) {\n      if (waitUntilError instanceof Error) {\n        error = waitUntilError;\n      }\n    }\n    await handler.runCallbacks('handlerDidComplete', {\n      event,\n      request,\n      response,\n      error: error\n    });\n    handler.destroy();\n    if (error) {\n      throw error;\n    }\n  }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\n/**\n * A {@link workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * {@link workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-precaching\n */\nclass PrecacheStrategy extends Strategy {\n  /**\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * {@link workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n   * of all fetch() requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n    super(options);\n    this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;\n    // Redirected responses cannot be used to satisfy a navigation request, so\n    // any redirected response must be \"copied\" rather than cloned, so the new\n    // response doesn't contain the `redirected` flag. See:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n    this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n  async _handle(request, handler) {\n    const response = await handler.cacheMatch(request);\n    if (response) {\n      return response;\n    }\n    // If this is an `install` event for an entry that isn't already cached,\n    // then populate the cache.\n    if (handler.event && handler.event.type === 'install') {\n      return await this._handleInstall(request, handler);\n    }\n    // Getting here means something went wrong. An entry that should have been\n    // precached wasn't found in the cache.\n    return await this._handleFetch(request, handler);\n  }\n  async _handleFetch(request, handler) {\n    let response;\n    const params = handler.params || {};\n    // Fall back to the network if we're configured to do so.\n    if (this._fallbackToNetwork) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn(`The precached response for ` + `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` + `found. Falling back to the network.`);\n      }\n      const integrityInManifest = params.integrity;\n      const integrityInRequest = request.integrity;\n      const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n      // Do not add integrity if the original request is no-cors\n      // See https://github.com/GoogleChrome/workbox/issues/3096\n      response = await handler.fetch(new Request(request, {\n        integrity: request.mode !== 'no-cors' ? integrityInRequest || integrityInManifest : undefined\n      }));\n      // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n      // that the response matches the precache manifest's expectations,\n      // and there's either a) no integrity property in the incoming request\n      // or b) there is an integrity, and it matches the precache manifest.\n      // See https://github.com/GoogleChrome/workbox/issues/2858\n      // Also if the original request users no-cors we don't use integrity.\n      // See https://github.com/GoogleChrome/workbox/issues/3096\n      if (integrityInManifest && noIntegrityConflict && request.mode !== 'no-cors') {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (process.env.NODE_ENV !== 'production') {\n          if (wasCached) {\n            logger.log(`A response for ${getFriendlyURL(request.url)} ` + `was used to \"repair\" the precache.`);\n          }\n        }\n      }\n    } else {\n      // This shouldn't normally happen, but there are edge cases:\n      // https://github.com/GoogleChrome/workbox/issues/1441\n      throw new WorkboxError('missing-precache-entry', {\n        cacheName: this.cacheName,\n        url: request.url\n      });\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n      // Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\n      logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n      logger.groupCollapsed(`View request details here.`);\n      logger.log(request);\n      logger.groupEnd();\n      logger.groupCollapsed(`View response details here.`);\n      logger.log(response);\n      logger.groupEnd();\n      logger.groupEnd();\n    }\n    return response;\n  }\n  async _handleInstall(request, handler) {\n    this._useDefaultCacheabilityPluginIfNeeded();\n    const response = await handler.fetch(request);\n    // Make sure we defer cachePut() until after we know the response\n    // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n    const wasCached = await handler.cachePut(request, response.clone());\n    if (!wasCached) {\n      // Throwing here will lead to the `install` handler failing, which\n      // we want to do if *any* of the responses aren't safe to cache.\n      throw new WorkboxError('bad-precaching-response', {\n        url: request.url,\n        status: response.status\n      });\n    }\n    return response;\n  }\n  /**\n   * This method is complex, as there a number of things to account for:\n   *\n   * The `plugins` array can be set at construction, and/or it might be added to\n   * to at any time before the strategy is used.\n   *\n   * At the time the strategy is used (i.e. during an `install` event), there\n   * needs to be at least one plugin that implements `cacheWillUpdate` in the\n   * array, other than `copyRedirectedCacheableResponsesPlugin`.\n   *\n   * - If this method is called and there are no suitable `cacheWillUpdate`\n   * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n   *\n   * - If this method is called and there is exactly one `cacheWillUpdate`, then\n   * we don't have to do anything (this might be a previously added\n   * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n   *\n   * - If this method is called and there is more than one `cacheWillUpdate`,\n   * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n   * we need to remove it. (This situation is unlikely, but it could happen if\n   * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n   * and then later on after manually adding a custom `cacheWillUpdate`.)\n   *\n   * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n   *\n   * @private\n   */\n  _useDefaultCacheabilityPluginIfNeeded() {\n    let defaultPluginIndex = null;\n    let cacheWillUpdatePluginCount = 0;\n    for (const [index, plugin] of this.plugins.entries()) {\n      // Ignore the copy redirected plugin when determining what to do.\n      if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n        continue;\n      }\n      // Save the default plugin's index, in case it needs to be removed.\n      if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n        defaultPluginIndex = index;\n      }\n      if (plugin.cacheWillUpdate) {\n        cacheWillUpdatePluginCount++;\n      }\n    }\n    if (cacheWillUpdatePluginCount === 0) {\n      this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n    } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n      // Only remove the default plugin; multiple custom plugins are allowed.\n      this.plugins.splice(defaultPluginIndex, 1);\n    }\n    // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n  }\n}\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n  async cacheWillUpdate(_ref) {\n    let {\n      response\n    } = _ref;\n    if (!response || response.status >= 400) {\n      return null;\n    }\n    return response;\n  }\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n  async cacheWillUpdate(_ref2) {\n    let {\n      response\n    } = _ref2;\n    return response.redirected ? await copyResponse(response) : response;\n  }\n};\nexport { PrecacheStrategy };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] The cache to use for precaching.\n   * @param {string} [options.plugins] Plugins to use when precaching as well\n   * as responding to fetch events for precached assets.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  constructor() {\n    let {\n      cacheName,\n      plugins = [],\n      fallbackToNetwork = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n    this._strategy = new PrecacheStrategy({\n      cacheName: cacheNames.getPrecacheName(cacheName),\n      plugins: [...plugins, new PrecacheCacheKeyPlugin({\n        precacheController: this\n      })],\n      fallbackToNetwork\n    });\n    // Bind the install and activate methods to the instance.\n    this.install = this.install.bind(this);\n    this.activate = this.activate.bind(this);\n  }\n  /**\n   * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n   * used to cache assets and respond to fetch events.\n   */\n  get strategy() {\n    return this._strategy;\n  }\n  /**\n   * Adds items to the precache list, removing any duplicates and\n   * stores the files in the\n   * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n   * worker installs.\n   *\n   * This method can be called multiple times.\n   *\n   * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n   */\n  precache(entries) {\n    this.addToCacheList(entries);\n    if (!this._installAndActiveListenersAdded) {\n      self.addEventListener('install', this.install);\n      self.addEventListener('activate', this.activate);\n      this._installAndActiveListenersAdded = true;\n    }\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n   *     Array of entries to precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries'\n      });\n    }\n    const urlsToWarnAbout = [];\n    for (const entry of entries) {\n      // See https://github.com/GoogleChrome/workbox/issues/2259\n      if (typeof entry === 'string') {\n        urlsToWarnAbout.push(entry);\n      } else if (entry && entry.revision === undefined) {\n        urlsToWarnAbout.push(entry.url);\n      }\n      const {\n        cacheKey,\n        url\n      } = createCacheKey(entry);\n      const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n      if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey\n        });\n      }\n      if (typeof entry !== 'string' && entry.integrity) {\n        if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n          throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n            url\n          });\n        }\n        this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n      }\n      this._urlsToCacheKeys.set(url, cacheKey);\n      this._urlsToCacheModes.set(url, cacheMode);\n      if (urlsToWarnAbout.length > 0) {\n        const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;\n        if (process.env.NODE_ENV === 'production') {\n          // Use console directly to display this warning without bloating\n          // bundle sizes by pulling in all of the logger codebase in prod.\n          console.warn(warningMessage);\n        } else {\n          logger.warn(warningMessage);\n        }\n      }\n    }\n  }\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<workbox-precaching.InstallResult>}\n   */\n  install(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return waitUntil(event, async () => {\n      const installReportPlugin = new PrecacheInstallReportPlugin();\n      this.strategy.plugins.push(installReportPlugin);\n      // Cache entries one at a time.\n      // See https://github.com/GoogleChrome/workbox/issues/2528\n      for (const [url, cacheKey] of this._urlsToCacheKeys) {\n        const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n        const cacheMode = this._urlsToCacheModes.get(url);\n        const request = new Request(url, {\n          integrity,\n          cache: cacheMode,\n          credentials: 'same-origin'\n        });\n        await Promise.all(this.strategy.handleAll({\n          params: {\n            cacheKey\n          },\n          request,\n          event\n        }));\n      }\n      const {\n        updatedURLs,\n        notUpdatedURLs\n      } = installReportPlugin;\n      if (process.env.NODE_ENV !== 'production') {\n        printInstallDetails(updatedURLs, notUpdatedURLs);\n      }\n      return {\n        updatedURLs,\n        notUpdatedURLs\n      };\n    });\n  }\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<workbox-precaching.CleanupResult>}\n   */\n  activate(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return waitUntil(event, async () => {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      const currentlyCachedRequests = await cache.keys();\n      const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n      const deletedURLs = [];\n      for (const request of currentlyCachedRequests) {\n        if (!expectedCacheKeys.has(request.url)) {\n          await cache.delete(request);\n          deletedURLs.push(request.url);\n        }\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        printCleanupDetails(deletedURLs);\n      }\n      return {\n        deletedURLs\n      };\n    });\n  }\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location.href);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n  /**\n   * @param {string} url A cache key whose SRI you want to look up.\n   * @return {string} The subresource integrity associated with the cache key,\n   * or undefined if it's not set.\n   */\n  getIntegrityForCacheKey(cacheKey) {\n    return this._cacheKeysToIntegrities.get(cacheKey);\n  }\n  /**\n   * This acts as a drop-in replacement for\n   * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n   * with the following differences:\n   *\n   * - It knows what the name of the precache is, and only checks in that cache.\n   * - It allows you to pass in an \"original\" URL without versioning parameters,\n   * and it will automatically look up the correct cache key for the currently\n   * active revision of that URL.\n   *\n   * E.g., `matchPrecache('index.html')` will find the correct precached\n   * response for the currently active service worker, even if the actual cache\n   * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n   *\n   * @param {string|Request} request The key (without revisioning parameters)\n   * to look up in the precache.\n   * @return {Promise<Response|undefined>}\n   */\n  async matchPrecache(request) {\n    const url = request instanceof Request ? request.url : request;\n    const cacheKey = this.getCacheKeyForURL(url);\n    if (cacheKey) {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      return cache.match(cacheKey);\n    }\n    return undefined;\n  }\n  /**\n   * Returns a function that looks up `url` in the precache (taking into\n   * account revision information), and returns the corresponding `Response`.\n   *\n   * @param {string} url The precached URL which will be used to lookup the\n   * `Response`.\n   * @return {workbox-routing~handlerCallback}\n   */\n  createHandlerBoundToURL(url) {\n    const cacheKey = this.getCacheKeyForURL(url);\n    if (!cacheKey) {\n      throw new WorkboxError('non-precached-url', {\n        url\n      });\n    }\n    return options => {\n      options.request = new Request(url);\n      options.params = Object.assign({\n        cacheKey\n      }, options.params);\n      return this.strategy.handle(options);\n    };\n  }\n}\nexport { PrecacheController };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { PrecacheController } from '../PrecacheController.js';\nimport '../_version.js';\nlet precacheController;\n/**\n * @return {PrecacheController}\n * @private\n */\nexport const getOrCreatePrecacheController = () => {\n  if (!precacheController) {\n    precacheController = new PrecacheController();\n  }\n  return precacheController;\n};","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @type {string}\n *\n * @private\n */\nexport const defaultMethod = 'GET';\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @type {Array<string>}\n *\n * @private\n */\nexport const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport '../_version.js';\n/**\n * @param {function()|Object} handler Either a function, or an object with a\n * 'handle' method.\n * @return {Object} An object with a handle method.\n *\n * @private\n */\nexport const normalizeHandler = handler => {\n  if (handler && typeof handler === 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.hasMethod(handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler'\n      });\n    }\n    return handler;\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(handler, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler'\n      });\n    }\n    return {\n      handle: handler\n    };\n  }\n};","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { defaultMethod, validMethods } from './utils/constants.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\n * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n * The \"match\" callback determine if a route should be used to \"handle\" a\n * request by returning a non-falsy value if it can. The \"handler\" callback\n * is called when there is a match and should return a Promise that resolves\n * to a `Response`.\n *\n * @memberof workbox-routing\n */\nclass Route {\n  /**\n   * Constructor for Route class.\n   *\n   * @param {workbox-routing~matchCallback} match\n   * A callback function that determines whether the route matches a given\n   * `fetch` event by returning a non-falsy value.\n   * @param {workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resolving to a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(match, handler) {\n    let method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultMethod;\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(match, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'match'\n      });\n      if (method) {\n        assert.isOneOf(method, validMethods, {\n          paramName: 'method'\n        });\n      }\n    }\n    // These values are referenced directly by Router so cannot be\n    // altered by minificaton.\n    this.handler = normalizeHandler(handler);\n    this.match = match;\n    this.method = method;\n  }\n  /**\n   *\n   * @param {workbox-routing-handlerCallback} handler A callback\n   * function that returns a Promise resolving to a Response\n   */\n  setCatchHandler(handler) {\n    this.catchHandler = normalizeHandler(handler);\n  }\n}\nexport { Route };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { Route } from './Route.js';\nimport './_version.js';\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * {@link workbox-routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * @memberof workbox-routing\n * @extends workbox-routing.Route\n */\nclass RegExpRoute extends Route {\n  /**\n   * If the regular expression contains\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n   * the captured values will be passed to the\n   * {@link workbox-routing~handlerCallback} `params`\n   * argument.\n   *\n   * @param {RegExp} regExp The regular expression to match against URLs.\n   * @param {workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(regExp, handler, method) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(regExp, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'RegExpRoute',\n        funcName: 'constructor',\n        paramName: 'pattern'\n      });\n    }\n    const match = _ref => {\n      let {\n        url\n      } = _ref;\n      const result = regExp.exec(url.href);\n      // Return immediately if there's no match.\n      if (!result) {\n        return;\n      }\n      // Require that the match start at the first character in the URL string\n      // if it's a cross-origin request.\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n      // behind this behavior.\n      if (url.origin !== location.origin && result.index !== 0) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`The regular expression '${regExp.toString()}' only partially matched ` + `against the cross-origin URL '${url.toString()}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);\n        }\n        return;\n      }\n      // If the route matches, but there aren't any capture groups defined, then\n      // this will return [], which is truthy and therefore sufficient to\n      // indicate a match.\n      // If there are capture groups, then it will return their values.\n      return result.slice(1);\n    };\n    super(match, handler, method);\n  }\n}\nexport { RegExpRoute };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { defaultMethod } from './utils/constants.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\n/**\n * The Router can be used to process a `FetchEvent` using one or more\n * {@link workbox-routing.Route}, responding with a `Response` if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox-routing\n */\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    this._routes = new Map();\n    this._defaultHandlerMap = new Map();\n  }\n  /**\n   * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n  get routes() {\n    return this._routes;\n  }\n  /**\n   * Adds a fetch event listener to respond to events when a route matches\n   * the event's request.\n   */\n  addFetchListener() {\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('fetch', event => {\n      const {\n        request\n      } = event;\n      const responsePromise = this.handleRequest({\n        request,\n        event\n      });\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n  /**\n   * Adds a message event listener for URLs to cache from the window.\n   * This is useful to cache resources loaded on the page prior to when the\n   * service worker started controlling it.\n   *\n   * The format of the message data sent from the window should be as follows.\n   * Where the `urlsToCache` array may consist of URL strings or an array of\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n   *\n   * ```\n   * {\n   *   type: 'CACHE_URLS',\n   *   payload: {\n   *     urlsToCache: [\n   *       './script1.js',\n   *       './script2.js',\n   *       ['./script3.js', {mode: 'no-cors'}],\n   *     ],\n   *   },\n   * }\n   * ```\n   */\n  addCacheListener() {\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('message', event => {\n      // event.data is type 'any'\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (event.data && event.data.type === 'CACHE_URLS') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const {\n          payload\n        } = event.data;\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n        }\n        const requestPromises = Promise.all(payload.urlsToCache.map(entry => {\n          if (typeof entry === 'string') {\n            entry = [entry];\n          }\n          const request = new Request(...entry);\n          return this.handleRequest({\n            request,\n            event\n          });\n          // TODO(philipwalton): TypeScript errors without this typecast for\n          // some reason (probably a bug). The real type here should work but\n          // doesn't: `Array<Promise<Response> | undefined>`.\n        })); // TypeScript\n        event.waitUntil(requestPromises);\n        // If a MessageChannel was used, reply to the message on success.\n        if (event.ports && event.ports[0]) {\n          void requestPromises.then(() => event.ports[0].postMessage(true));\n        }\n      }\n    });\n  }\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to handle.\n   * @param {ExtendableEvent} options.event The event that triggered the\n   *     request.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   *     registered route can handle the request. If there is no matching\n   *     route and there's no `defaultHandler`, `undefined` is returned.\n   */\n  handleRequest(_ref) {\n    let {\n      request,\n      event\n    } = _ref;\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'handleRequest',\n        paramName: 'options.request'\n      });\n    }\n    const url = new URL(request.url, location.href);\n    if (!url.protocol.startsWith('http')) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n      }\n      return;\n    }\n    const sameOrigin = url.origin === location.origin;\n    const {\n      params,\n      route\n    } = this.findMatchingRoute({\n      event,\n      request,\n      sameOrigin,\n      url\n    });\n    let handler = route && route.handler;\n    const debugMessages = [];\n    if (process.env.NODE_ENV !== 'production') {\n      if (handler) {\n        debugMessages.push([`Found a route to handle this request:`, route]);\n        if (params) {\n          debugMessages.push([`Passing the following params to the route's handler:`, params]);\n        }\n      }\n    }\n    // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n    const method = request.method;\n    if (!handler && this._defaultHandlerMap.has(method)) {\n      if (process.env.NODE_ENV !== 'production') {\n        debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler for ${method}.`);\n      }\n      handler = this._defaultHandlerMap.get(method);\n    }\n    if (!handler) {\n      if (process.env.NODE_ENV !== 'production') {\n        // No handler so Workbox will do nothing. If logs is set of debug\n        // i.e. verbose, we should print out this information.\n        logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n      }\n      return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      // We have a handler, meaning Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n      debugMessages.forEach(msg => {\n        if (Array.isArray(msg)) {\n          logger.log(...msg);\n        } else {\n          logger.log(msg);\n        }\n      });\n      logger.groupEnd();\n    }\n    // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n    let responsePromise;\n    try {\n      responsePromise = handler.handle({\n        url,\n        request,\n        event,\n        params\n      });\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    }\n    // Get route's catch handler, if it exists\n    const catchHandler = route && route.catchHandler;\n    if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n      responsePromise = responsePromise.catch(async err => {\n        // If there's a route catch handler, process that first\n        if (catchHandler) {\n          if (process.env.NODE_ENV !== 'production') {\n            // Still include URL here as it will be async from the console group\n            // and may not make sense without the URL\n            logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);\n            logger.error(`Error thrown by:`, route);\n            logger.error(err);\n            logger.groupEnd();\n          }\n          try {\n            return await catchHandler.handle({\n              url,\n              request,\n              event,\n              params\n            });\n          } catch (catchErr) {\n            if (catchErr instanceof Error) {\n              err = catchErr;\n            }\n          }\n        }\n        if (this._catchHandler) {\n          if (process.env.NODE_ENV !== 'production') {\n            // Still include URL here as it will be async from the console group\n            // and may not make sense without the URL\n            logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);\n            logger.error(`Error thrown by:`, route);\n            logger.error(err);\n            logger.groupEnd();\n          }\n          return this._catchHandler.handle({\n            url,\n            request,\n            event\n          });\n        }\n        throw err;\n      });\n    }\n    return responsePromise;\n  }\n  /**\n   * Checks a request and URL (and optionally an event) against the list of\n   * registered routes, and if there's a match, returns the corresponding\n   * route along with any params generated by the match.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n   *     against the current origin.\n   * @param {Request} options.request The request to match.\n   * @param {Event} options.event The corresponding event.\n   * @return {Object} An object with `route` and `params` properties.\n   *     They are populated if a matching route was found or `undefined`\n   *     otherwise.\n   */\n  findMatchingRoute(_ref2) {\n    let {\n      url,\n      sameOrigin,\n      request,\n      event\n    } = _ref2;\n    const routes = this._routes.get(request.method) || [];\n    for (const route of routes) {\n      let params;\n      // route.match returns type any, not possible to change right now.\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const matchResult = route.match({\n        url,\n        sameOrigin,\n        request,\n        event\n      });\n      if (matchResult) {\n        if (process.env.NODE_ENV !== 'production') {\n          // Warn developers that using an async matchCallback is almost always\n          // not the right thing to do.\n          if (matchResult instanceof Promise) {\n            logger.warn(`While routing ${getFriendlyURL(url)}, an async ` + `matchCallback function was used. Please convert the ` + `following route to use a synchronous matchCallback function:`, route);\n          }\n        }\n        // See https://github.com/GoogleChrome/workbox/issues/2079\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        params = matchResult;\n        if (Array.isArray(params) && params.length === 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          params = undefined;\n        } else if (matchResult.constructor === Object &&\n        // eslint-disable-line\n        Object.keys(matchResult).length === 0) {\n          // Instead of passing an empty object in as params, use undefined.\n          params = undefined;\n        } else if (typeof matchResult === 'boolean') {\n          // For the boolean value true (rather than just something truth-y),\n          // don't set params.\n          // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n          params = undefined;\n        }\n        // Return early if have a match.\n        return {\n          route,\n          params\n        };\n      }\n    }\n    // If no match was found above, return and empty object.\n    return {};\n  }\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to associate with this\n   * default handler. Each method has its own default.\n   */\n  setDefaultHandler(handler) {\n    let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultMethod;\n    this._defaultHandlerMap.set(method, normalizeHandler(handler));\n  }\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setCatchHandler(handler) {\n    this._catchHandler = normalizeHandler(handler);\n  }\n  /**\n   * Registers a route with the router.\n   *\n   * @param {workbox-routing.Route} route The route to register.\n   */\n  registerRoute(route) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(route, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.hasMethod(route, 'match', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.isType(route.handler, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.hasMethod(route.handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.handler'\n      });\n      assert.isType(route.method, 'string', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.method'\n      });\n    }\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    }\n    // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n    this._routes.get(route.method).push(route);\n  }\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {workbox-routing.Route} route The route to unregister.\n   */\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new WorkboxError('unregister-route-but-not-found-with-method', {\n        method: route.method\n      });\n    }\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new WorkboxError('unregister-route-route-not-registered');\n    }\n  }\n}\nexport { Router };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Router } from '../Router.js';\nimport '../_version.js';\nlet defaultRouter;\n/**\n * Creates a new, singleton Router instance if one does not exist. If one\n * does already exist, that instance is returned.\n *\n * @private\n * @return {Router}\n */\nexport const getOrCreateDefaultRouter = () => {\n  if (!defaultRouter) {\n    defaultRouter = new Router();\n    // The helpers that use the default Router assume these listeners exist.\n    defaultRouter.addFetchListener();\n    defaultRouter.addCacheListener();\n  }\n  return defaultRouter;\n};","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Route } from './Route.js';\nimport { RegExpRoute } from './RegExpRoute.js';\nimport { getOrCreateDefaultRouter } from './utils/getOrCreateDefaultRouter.js';\nimport './_version.js';\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call {@link workbox-routing.Router#registerRoute}.\n *\n * @param {RegExp|string|workbox-routing.Route~matchCallback|workbox-routing.Route} capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {workbox-routing~handlerCallback} [handler] A callback\n * function that returns a Promise resulting in a Response. This parameter\n * is required if `capture` is not a `Route` object.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {workbox-routing.Route} The generated `Route`.\n *\n * @memberof workbox-routing\n */\nfunction registerRoute(capture, handler, method) {\n  let route;\n  if (typeof capture === 'string') {\n    const captureUrl = new URL(capture, location.href);\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n        throw new WorkboxError('invalid-string', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture'\n        });\n      }\n      // We want to check if Express-style wildcards are in the pathname only.\n      // TODO: Remove this log message in v4.\n      const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture;\n      // See https://github.com/pillarjs/path-to-regexp#parameters\n      const wildcards = '[*:?+]';\n      if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n        logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);\n      }\n    }\n    const matchCallback = _ref => {\n      let {\n        url\n      } = _ref;\n      if (process.env.NODE_ENV !== 'production') {\n        if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n          logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url.toString()}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);\n        }\n      }\n      return url.href === captureUrl.href;\n    };\n    // If `capture` is a string then `handler` and `method` must be present.\n    route = new Route(matchCallback, handler, method);\n  } else if (capture instanceof RegExp) {\n    // If `capture` is a `RegExp` then `handler` and `method` must be present.\n    route = new RegExpRoute(capture, handler, method);\n  } else if (typeof capture === 'function') {\n    // If `capture` is a function then `handler` and `method` must be present.\n    route = new Route(capture, handler, method);\n  } else if (capture instanceof Route) {\n    route = capture;\n  } else {\n    throw new WorkboxError('unsupported-route-type', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerRoute',\n      paramName: 'capture'\n    });\n  }\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.registerRoute(route);\n  return route;\n}\nexport { registerRoute };","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { Route } from 'workbox-routing/Route.js';\nimport { generateURLVariations } from './utils/generateURLVariations.js';\nimport './_version.js';\n/**\n * A subclass of {@link workbox-routing.Route} that takes a\n * {@link workbox-precaching.PrecacheController}\n * instance and uses it to match incoming requests and handle fetching\n * responses from the precache.\n *\n * @memberof workbox-precaching\n * @extends workbox-routing.Route\n */\nclass PrecacheRoute extends Route {\n  /**\n   * @param {PrecacheController} precacheController A `PrecacheController`\n   * instance used to both match requests and respond to fetch events.\n   * @param {Object} [options] Options to control how requests are matched\n   * against the list of precached URLs.\n   * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n   * check cache entries for a URLs ending with '/' to see if there is a hit when\n   * appending the `directoryIndex` value.\n   * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An\n   * array of regex's to remove search params when looking for a cache match.\n   * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n   * check the cache for the URL with a `.html` added to the end of the end.\n   * @param {workbox-precaching~urlManipulation} [options.urlManipulation]\n   * This is a function that should take a URL and return an array of\n   * alternative URLs that should be checked for precache matches.\n   */\n  constructor(precacheController, options) {\n    const match = _ref => {\n      let {\n        request\n      } = _ref;\n      const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n      for (const possibleURL of generateURLVariations(request.url, options)) {\n        const cacheKey = urlsToCacheKeys.get(possibleURL);\n        if (cacheKey) {\n          const integrity = precacheController.getIntegrityForCacheKey(cacheKey);\n          return {\n            cacheKey,\n            integrity\n          };\n        }\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));\n      }\n      return;\n    };\n    super(match, precacheController.strategy);\n  }\n}\nexport { PrecacheRoute };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { removeIgnoredSearchParams } from './removeIgnoredSearchParams.js';\nimport '../_version.js';\n/**\n * Generator function that yields possible variations on the original URL to\n * check, one at a time.\n *\n * @param {string} url\n * @param {Object} options\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function generateURLVariations(url) {\n  let {\n    ignoreURLParametersMatching = [/^utm_/, /^fbclid$/],\n    directoryIndex = 'index.html',\n    cleanURLs = true,\n    urlManipulation\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    const urlObject = new URL(url, location.href);\n    urlObject.hash = '';\n    yield urlObject.href;\n    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n    yield urlWithoutIgnoredParams.href;\n    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n      const directoryURL = new URL(urlWithoutIgnoredParams.href);\n      directoryURL.pathname += directoryIndex;\n      yield directoryURL.href;\n    }\n    if (cleanURLs) {\n      const cleanURL = new URL(urlWithoutIgnoredParams.href);\n      cleanURL.pathname += '.html';\n      yield cleanURL.href;\n    }\n    if (urlManipulation) {\n      const additionalURLs = urlManipulation({\n        url: urlObject\n      });\n      for (const urlToAttempt of additionalURLs) {\n        yield urlToAttempt.href;\n      }\n    }\n  }();\n}","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Removes any URL search parameters that should be ignored.\n *\n * @param {URL} urlObject The original URL.\n * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n * each search parameter name. Matches mean that the search parameter should be\n * ignored.\n * @return {URL} The URL with any ignored search parameters removed.\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function removeIgnoredSearchParams(urlObject) {\n  let ignoreURLParametersMatching = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // Convert the iterable into an array at the start of the loop to make sure\n  // deletion doesn't mess up iteration.\n  for (const paramName of [...urlObject.searchParams.keys()]) {\n    if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {\n      urlObject.searchParams.delete(paramName);\n    }\n  }\n  return urlObject;\n}","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nexport const cacheOkAndOpaquePlugin = {\n  /**\n   * Returns a valid response (to allow caching) if the status is 200 (OK) or\n   * 0 (opaque).\n   *\n   * @param {Object} options\n   * @param {Response} options.response\n   * @return {Response|null}\n   *\n   * @private\n   */\n  cacheWillUpdate: async _ref => {\n    let {\n      response\n    } = _ref;\n    if (response.status === 200 || response.status === 0) {\n      return response;\n    }\n    return null;\n  }\n};","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { addRoute } from './addRoute.js';\nimport { precache } from './precache.js';\nimport './_version.js';\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * {@link workbox-precaching.precache} and\n * {@link workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} [options] See the\n * {@link workbox-precaching.PrecacheRoute} options.\n *\n * @memberof workbox-precaching\n */\nfunction precacheAndRoute(entries, options) {\n  precache(entries);\n  addRoute(options);\n}\nexport { precacheAndRoute };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport './_version.js';\n/**\n * Claim any currently available clients once the service worker\n * becomes active. This is normally used in conjunction with `skipWaiting()`.\n *\n * @memberof workbox-core\n */\nfunction clientsClaim() {\n  self.addEventListener('activate', () => self.clients.claim());\n}\nexport { clientsClaim };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport './_version.js';\n/**\n * Adds items to the precache list, removing any duplicates and\n * stores the files in the\n * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you.\n * It only precaches files. To respond to a network request you call\n * {@link workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * {@link workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n *\n * @memberof workbox-precaching\n */\nfunction precache(entries) {\n  const precacheController = getOrCreatePrecacheController();\n  precacheController.precache(entries);\n}\nexport { precache };","/// <reference lib=\"webworker\" />\r\n\r\n// This service worker can be customized!\r\n// See https://developers.google.com/web/tools/workbox/modules\r\n// for the list of available Workbox modules, or add any other\r\n// code you'd like.\r\n// You can also remove this file if you'd prefer not to use a\r\n// service worker, and the Workbox build step will be skipped.\r\n\r\nimport { clientsClaim } from 'workbox-core'\r\nimport { ExpirationPlugin } from 'workbox-expiration'\r\nimport { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching'\r\nimport { registerRoute } from 'workbox-routing'\r\nimport { StaleWhileRevalidate } from 'workbox-strategies'\r\n\r\ndeclare const self: ServiceWorkerGlobalScope\r\n\r\nclientsClaim()\r\n\r\n// Precache all of the assets generated by your build process.\r\n// Their URLs are injected into the manifest variable below.\r\n// This variable must be present somewhere in your service worker file,\r\n// even if you decide not to use precaching. See https://cra.link/PWA\r\n\r\nprecacheAndRoute(self.__WB_MANIFEST)\r\n\r\n// Set up App Shell-style routing, so that all navigation requests\r\n// are fulfilled with your index.html shell. Learn more at\r\n// https://developers.google.com/web/fundamentals/architecture/app-shell\r\nconst fileExtensionRegexp = /\\/[^/?]+\\.[^/]+$/\r\nregisterRoute(\r\n  // Return false to exempt requests from being fulfilled by index.html.\r\n  ({ request, url }: { request: Request; url: URL }) => {\r\n    // If this isn't a navigation, skip.\r\n    if (request.mode !== 'navigate') {\r\n      return false\r\n    }\r\n\r\n    // If this is a URL that starts with /_, skip.\r\n    if (url.pathname.startsWith('/_')) {\r\n      return false\r\n    }\r\n\r\n    // If this looks like a URL for a resource, because it contains\r\n    // a file extension, skip.\r\n    if (url.pathname.match(fileExtensionRegexp)) {\r\n      return false\r\n    }\r\n\r\n    // Return true to signal that we want to use the handler.\r\n    return true\r\n  },\r\n  createHandlerBoundToURL(`${process.env.PUBLIC_URL}/index.html`)\r\n)\r\n\r\n// An example runtime caching route for requests that aren't handled by the\r\n// precache, in this case same-origin .png requests like those from in public/\r\nregisterRoute(\r\n  // Add in any other file extensions or routing criteria as needed.\r\n  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),\r\n  // Customize this strategy as needed, e.g., by changing to CacheFirst.\r\n  new StaleWhileRevalidate({\r\n    cacheName: 'images',\r\n    plugins: [\r\n      // Ensure that once this runtime cache reaches a maximum size the\r\n      // least-recently used images are removed.\r\n      new ExpirationPlugin({ maxEntries: 50 })\r\n    ]\r\n  })\r\n)\r\n\r\n// This allows the web app to trigger skipWaiting via\r\n// registration.waiting.postMessage({type: 'SKIP_WAITING'})\r\nself.addEventListener('message', (event) => {\r\n  if (event.data && event.data.type === 'SKIP_WAITING') {\r\n    self.skipWaiting()\r\n  }\r\n})\r\n\r\n// Any other custom service worker logic can go here.\r\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport { PrecacheRoute } from './PrecacheRoute.js';\nimport './_version.js';\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} [options] See the {@link workbox-precaching.PrecacheRoute}\n * options.\n *\n * @memberof workbox-precaching\n */\nfunction addRoute(options) {\n  const precacheController = getOrCreatePrecacheController();\n  const precacheRoute = new PrecacheRoute(precacheController, options);\n  registerRoute(precacheRoute);\n}\nexport { addRoute };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport './_version.js';\n/**\n * Helper function that calls\n * {@link PrecacheController#createHandlerBoundToURL} on the default\n * {@link PrecacheController} instance.\n *\n * If you are creating your own {@link PrecacheController}, then call the\n * {@link PrecacheController#createHandlerBoundToURL} on that instance,\n * instead of using this function.\n *\n * @param {string} url The precached URL which will be used to lookup the\n * `Response`.\n * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n * response from the network if there's a precache miss.\n * @return {workbox-routing~handlerCallback}\n *\n * @memberof workbox-precaching\n */\nfunction createHandlerBoundToURL(url) {\n  const precacheController = getOrCreatePrecacheController();\n  return precacheController.createHandlerBoundToURL(url);\n}\nexport { createHandlerBoundToURL };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [stale-while-revalidate](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate)\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).\n * Opaque responses are cross-origin requests where the response doesn't\n * support [CORS](https://enable-cors.org/).\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass StaleWhileRevalidate extends Strategy {\n  /**\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * {@link workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n    // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n    if (!this.plugins.some(p => 'cacheWillUpdate' in p)) {\n      this.plugins.unshift(cacheOkAndOpaquePlugin);\n    }\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n  async _handle(request, handler) {\n    const logs = [];\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: this.constructor.name,\n        funcName: 'handle',\n        paramName: 'request'\n      });\n    }\n    const fetchAndCachePromise = handler.fetchAndCachePut(request).catch(() => {\n      // Swallow this error because a 'no-response' error will be thrown in\n      // main handler return flow. This will be in the `waitUntil()` flow.\n    });\n    void handler.waitUntil(fetchAndCachePromise);\n    let response = await handler.cacheMatch(request);\n    let error;\n    if (response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`Found a cached response in the '${this.cacheName}'` + ` cache. Will update with the network response in the background.`);\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`No response found in the '${this.cacheName}' cache. ` + `Will wait for the network response.`);\n      }\n      try {\n        // NOTE(philipwalton): Really annoying that we have to type cast here.\n        // https://github.com/microsoft/TypeScript/issues/20006\n        response = await fetchAndCachePromise;\n      } catch (err) {\n        if (err instanceof Error) {\n          error = err;\n        }\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n      for (const log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n    if (!response) {\n      throw new WorkboxError('no-response', {\n        url: request.url,\n        error\n      });\n    }\n    return response;\n  }\n}\nexport { StaleWhileRevalidate };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheExpiration } from './CacheExpiration.js';\nimport './_version.js';\n/**\n * This plugin can be used in a `workbox-strategy` to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * It can only be used with `workbox-strategy` instances that have a\n * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\n * In other words, it can't be used to expire entries in strategy that uses the\n * default runtime cache name.\n *\n * Whenever a cached response is used or updated, this plugin will look\n * at the associated cache and remove any old or extra responses.\n *\n * When using `maxAgeSeconds`, responses may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached response has been used. If the response has a \"Date\" header, then\n * a light weight expiration check is performed and the response will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof workbox-expiration\n */\nclass ExpirationPlugin {\n  /**\n   * @param {ExpirationPluginOptions} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n   * that will be used when calling `delete()` on the cache.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox-strategies` handlers when a `Response` is about to be returned\n     * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n     * the handler. It allows the `Response` to be inspected for freshness and\n     * prevents it from being used if the `Response`'s `Date` header value is\n     * older than the configured `maxAgeSeconds`.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache the response is in.\n     * @param {Response} options.cachedResponse The `Response` object that's been\n     *     read from a cache and whose freshness should be checked.\n     * @return {Response} Either the `cachedResponse`, if it's\n     *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n     *\n     * @private\n     */\n    this.cachedResponseWillBeUsed = async _ref => {\n      let {\n        event,\n        request,\n        cacheName,\n        cachedResponse\n      } = _ref;\n      if (!cachedResponse) {\n        return null;\n      }\n      const isFresh = this._isResponseDateFresh(cachedResponse);\n      // Expire entries to ensure that even if the expiration date has\n      // expired, it'll only be used once.\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n      dontWaitFor(cacheExpiration.expireEntries());\n      // Update the metadata for the request URL to the current timestamp,\n      // but don't `await` it as we don't want to block the response.\n      const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n      if (event) {\n        try {\n          event.waitUntil(updateTimestampDone);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            // The event may not be a fetch event; only log the URL if it is.\n            if ('request' in event) {\n              logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache entry for ` + `'${getFriendlyURL(event.request.url)}'.`);\n            }\n          }\n        }\n      }\n      return isFresh ? cachedResponse : null;\n    };\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox-strategies` handlers when an entry is added to a cache.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache that was updated.\n     * @param {string} options.request The Request for the cached entry.\n     *\n     * @private\n     */\n    this.cacheDidUpdate = async _ref2 => {\n      let {\n        cacheName,\n        request\n      } = _ref2;\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isType(cacheName, 'string', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'cacheName'\n        });\n        assert.isInstance(request, Request, {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'request'\n        });\n      }\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n      await cacheExpiration.updateTimestamp(request.url);\n      await cacheExpiration.expireEntries();\n    };\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor'\n        });\n      }\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        });\n      }\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        });\n      }\n    }\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n  }\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n  _getCacheExpiration(cacheName) {\n    if (cacheName === cacheNames.getRuntimeName()) {\n      throw new WorkboxError('expire-custom-caches-only');\n    }\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n    return cacheExpiration;\n  }\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    }\n    // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    }\n    // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n  }\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number|null}\n   *\n   * @private\n   */\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime();\n    // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n    if (isNaN(headerTime)) {\n      return null;\n    }\n    return headerTime;\n  }\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await self.caches.delete(cacheName);\n      await cacheExpiration.delete();\n    }\n    // Reset this._cacheExpirations to its initial state.\n    this._cacheExpirations = new Map();\n  }\n}\nexport { ExpirationPlugin };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from './_private/logger.js';\nimport { assert } from './_private/assert.js';\nimport { quotaErrorCallbacks } from './models/quotaErrorCallbacks.js';\nimport './_version.js';\n/**\n * Adds a function to the set of quotaErrorCallbacks that will be executed if\n * there's a quota error.\n *\n * @param {Function} callback\n * @memberof workbox-core\n */\n// Can't change Function type\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction registerQuotaErrorCallback(callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(callback, 'function', {\n      moduleName: 'workbox-core',\n      funcName: 'register',\n      paramName: 'callback'\n    });\n  }\n  quotaErrorCallbacks.add(callback);\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Registered a callback to respond to quota errors.', callback);\n  }\n}\nexport { registerQuotaErrorCallback };"]}